<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StayFocused - Dev Productivity Suite</title>
  <style>
    /* Variables */
    :root {
      --primary-color: #4a6da7;
      --primary-dark: #344e7a;
      --primary-light: #6b8ac0;
      --background: #f5f7fa;
      --text-color: #333;
      --border-color: #ddd;
      --success-color: #4CAF50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background);
      color: var(--text-color);
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    header {
      background: var(--primary-color);
      color: white;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      margin: 0;
      font-size: 24px;
    }

    .focus-status {
      display: flex;
      align-items: center;
    }

    #status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #888;
      margin-right: 8px;
      transition: background-color 0.3s;
    }

    #status-indicator.active {
      background-color: var(--success-color);
    }

    #focus-state {
      font-weight: bold;
    }

    #focus-state.active {
      color: var(--success-color);
    }

    section {
      padding: 20px;
    }

    h2 {
      margin-bottom: 15px;
      font-size: 20px;
      color: var(--primary-dark);
    }

    .timer-section {
      background-color: #f8f9fa;
      text-align: center;
      padding: 30px 20px;
      margin-bottom: 20px;
      border-radius: 4px;
      display: none;
    }

    .timer-section.active {
      display: block;
    }

    #remaining-time {
      font-size: 36px;
      font-weight: bold;
      color: var(--primary-color);
      margin: 15px 0;
    }

    .form-group {
      margin-bottom: 15px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .form-control {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 16px;
    }

    .duration-option {
      display: none;
      margin-top: 10px;
    }

    .duration-option.active {
      display: block;
    }

    .btn {
      display: inline-block;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      text-align: center;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn:hover {
      opacity: 0.9;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .primary {
      background-color: var(--primary-color);
      color: white;
    }

    .secondary {
      background-color: #6c757d;
      color: white;
    }

    .danger {
      background-color: var(--danger-color);
      color: white;
    }

    .text {
      background: transparent;
      color: var(--primary-color);
    }

    .list-section {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .list-container {
      flex: 1;
      min-width: 250px;
    }

    .site-input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .site-input-group .form-control {
      flex: 1;
    }

    .sites-list {
      list-style: none;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .sites-list li {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .sites-list li:last-child {
      border-bottom: none;
    }

    .remove-btn {
      background: transparent;
      border: none;
      color: var(--danger-color);
      cursor: pointer;
      font-size: 18px;
      padding: 0 5px;
    }

    footer {
      text-align: center;
      padding: 15px;
      border-top: 1px solid var(--border-color);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>StayFocused</h1>
      <div class="focus-status">
        <span id="status-indicator"></span>
        <span id="status-text">Focus mode: <span id="focus-state">OFF</span></span>
      </div>
    </header>

    <section class="timer-section" id="timer-display">
      <div id="remaining-time-container">
        <h3></h3>Remaining time:</h3>
        <div id="remaining-time">--:--:--</div>
        <button id="stop-focus" class="btn danger">Stop Focus Mode</button>
      </div>
    </section>

    <section id="focus-controls">
      <h2>Focus Settings</h2>

      <div class="form-group">
        <label for="block-type">Block Duration:</label>
        <select id="block-type" class="form-control">
          <option value="timed">For a fixed time</option>
          <option value="untilTime">Until a specific time</option>
          <option value="indefinite">Indefinitely</option>
        </select>
      </div>

      <div id="fixed-time-options" class="duration-option">
        <div class="form-group">
          <label for="duration-hours">Hours:</label>
          <input type="number" id="duration-hours" class="form-control" min="0" max="23" value="1">
        </div>
        <div class="form-group">
          <label for="duration-minutes">Minutes:</label>
          <input type="number" id="duration-minutes" class="form-control" min="0" max="59" value="0">
        </div>
      </div>

      <div id="until-time-options" class="duration-option">
        <div class="form-group">
          <label for="end-time">End time:</label>
          <input type="time" id="end-time" class="form-control">
        </div>
      </div>

      <div class="form-group">
        <label for="start-now">
          <input type="checkbox" id="start-now" checked>
          Start blocking now
        </label>
      </div>

      <div id="delayed-start-options" class="duration-option">
        <div class="form-group">
          <label for="start-time">Start time:</label>
          <input type="time" id="start-time" class="form-control">
        </div>
      </div>

      <button id="start-focus" class="btn primary">Start Focus Mode</button>
    </section>

    <section class="list-section">
      <div class="list-container">
        <h2>Blocked Sites</h2>
        <div class="site-input-group">
          <input type="text" id="new-blocked-site" placeholder="e.g., facebook.com" class="form-control">
          <button id="add-blocked-site" class="btn secondary">Add</button>
        </div>
        <ul id="blocked-sites-list" class="sites-list"></ul>
      </div>

      <div class="list-container">
        <h2>Always Allow</h2>
        <div class="site-input-group">
          <input type="text" id="new-allowed-site" placeholder="e.g., google.com" class="form-control">
          <button id="add-allowed-site" class="btn secondary">Add</button>
        </div>
        <ul id="allowed-sites-list" class="sites-list"></ul>
      </div>
    </section>

    <footer>
      <button id="close-page" class="btn text">Close</button>
    </footer>
  </div>

  <script>
    // Storage keys
    const STORAGE_KEYS = {
      BLACKLIST: 'blacklist',
      WHITELIST: 'whitelist',
      FOCUS_STATE: 'focusState',
      START_TIME: 'startTime',
      END_TIME: 'endTime',
      BLOCK_MODE: 'blockMode'
    };

    // DOM Elements
    const elements = {
      // Status elements
      statusIndicator: document.getElementById('status-indicator'),
      focusState: document.getElementById('focus-state'),

      // Timer section
      timerSection: document.getElementById('timer-display'),
      remainingTime: document.getElementById('remaining-time'),
      stopFocusBtn: document.getElementById('stop-focus'),

      // Focus controls
      focusControls: document.getElementById('focus-controls'),
      blockType: document.getElementById('block-type'),
      startFocusBtn: document.getElementById('start-focus'),

      // Duration options
      fixedTimeOptions: document.getElementById('fixed-time-options'),
      untilTimeOptions: document.getElementById('until-time-options'),
      durationHours: document.getElementById('duration-hours'),
      durationMinutes: document.getElementById('duration-minutes'),
      endTime: document.getElementById('end-time'),

      // Start options
      startNow: document.getElementById('start-now'),
      delayedStartOptions: document.getElementById('delayed-start-options'),
      startTime: document.getElementById('start-time'),

      // Site lists
      blockedSiteInput: document.getElementById('new-blocked-site'),
      allowedSiteInput: document.getElementById('new-allowed-site'),
      blockedSitesList: document.getElementById('blocked-sites-list'),
      allowedSitesList: document.getElementById('allowed-sites-list'),
      addBlockedSiteBtn: document.getElementById('add-blocked-site'),
      addAllowedSiteBtn: document.getElementById('add-allowed-site'),

      // Options
      closePageBtn: document.getElementById('close-page')
    };

    // Initialize the page
    async function initializePage() {
      // Get current status from background
      const status = await getFocusStatus();

      // Update UI based on current status
      updateFocusStatus(status.focusState, status.endTime);

      // Get site lists from background
      const lists = await getSiteLists();

      // Update lists in UI
      populateSiteLists(lists.blacklist, lists.whitelist);

      // Set block type
      elements.blockType.value = status.blockMode || 'timed';
      handleBlockTypeChange();

      // Set default times
      setDefaultTimes();

      // Set up event listeners
      setupEventListeners();
    }

    /**
     * Get current focus status from background
     */
    async function getFocusStatus() {
      return new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'FOCUS_GET_STATUS' }, (response) => {
          if (response && response.success) {
            resolve({
              focusState: response.focusState || false,
              startTime: response.startTime || null,
              endTime: response.endTime || null,
              blockMode: response.blockMode || 'timed'
            });
          } else {
            resolve({
              focusState: false,
              startTime: null,
              endTime: null,
              blockMode: 'timed'
            });
          }
        });
      });
    }

    /**
     * Get site lists from background
     */
    async function getSiteLists() {
      return new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'FOCUS_GET_SITES' }, (response) => {
          if (response && response.success) {
            resolve({
              blacklist: response.blacklist || [],
              whitelist: response.whitelist || []
            });
          } else {
            resolve({
              blacklist: [],
              whitelist: []
            });
          }
        });
      });
    }

    /**
     * Update the focus status UI
     */
    function updateFocusStatus(isActive, endTimeString) {
      if (isActive) {
        // Update status indicator
        elements.statusIndicator.classList.add('active');
        elements.focusState.textContent = 'ON';
        elements.focusState.classList.add('active');

        // Show timer section, hide controls
        elements.timerSection.classList.add('active');
        elements.focusControls.style.display = 'none';

        // Update remaining time if endTimeString is provided
        if (endTimeString) {
          updateRemainingTime(endTimeString);
          // Start timer update interval
          startTimerInterval(endTimeString);
        } else {
          elements.remainingTime.textContent = 'Until manually disabled';
        }
      } else {
        // Update status indicator to inactive
        elements.statusIndicator.classList.remove('active');
        elements.focusState.textContent = 'OFF';
        elements.focusState.classList.remove('active');

        // Hide timer section, show controls
        elements.timerSection.classList.remove('active');
        elements.focusControls.style.display = 'block';

        // Stop timer interval if it's running
        stopTimerInterval();
      }
    }

    /**
     * Set up a timer interval to update remaining time
     */
    let timerIntervalId = null;
    function startTimerInterval(endTimeString) {
      // Clear any existing interval
      stopTimerInterval();

      // Update immediately
      updateRemainingTime(endTimeString);

      // Set interval to update every second
      timerIntervalId = setInterval(() => {
        const stillActive = updateRemainingTime(endTimeString);
        if (!stillActive) {
          // Time has expired, refresh UI
          getFocusStatus().then((status) => {
            updateFocusStatus(status.focusState, status.endTime);
          });
        }
      }, 1000);
    }

    /**
     * Stop the timer interval
     */
    function stopTimerInterval() {
      if (timerIntervalId !== null) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
    }

    /**
     * Update remaining time display
     * Returns false if time has expired, true otherwise
     */
    function updateRemainingTime(endTimeString) {
      const now = new Date();
      const endTime = new Date(endTimeString);

      // If end time has passed, return false
      if (now >= endTime) {
        elements.remainingTime.textContent = 'Time expired';
        return false;
      }

      // Calculate time difference
      const diff = endTime - now;

      // Format time difference
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      // Format with leading zeros
      const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

      // Update display
      elements.remainingTime.textContent = formattedTime;

      return true;
    }

    /**
     * Populate blocked and allowed sites lists
     */
    function populateSiteLists(blacklist, whitelist) {
      // Clear existing lists
      elements.blockedSitesList.innerHTML = '';
      elements.allowedSitesList.innerHTML = '';

      // Add blacklisted sites
      blacklist.forEach(site => {
        addSiteToList(site, elements.blockedSitesList, 'blacklist');
      });

      // Add whitelisted sites
      whitelist.forEach(site => {
        addSiteToList(site, elements.allowedSitesList, 'whitelist');
      });
    }

    /**
     * Add a site to a list with remove button
     */
    function addSiteToList(site, listElement, listType) {
      const li = document.createElement('li');

      const siteText = document.createElement('span');
      siteText.textContent = site;
      li.appendChild(siteText);

      const removeBtn = document.createElement('button');
      removeBtn.innerHTML = '&times;';
      removeBtn.className = 'remove-btn';
      removeBtn.addEventListener('click', () => removeSite(site, listType));
      li.appendChild(removeBtn);

      listElement.appendChild(li);
    }

    /**
     * Remove a site from storage and UI
     */
    async function removeSite(site, listType) {
      // Get current lists
      const lists = await getSiteLists();

      // Update the appropriate list
      if (listType === 'blacklist') {
        lists.blacklist = lists.blacklist.filter(s => s !== site);
      } else {
        lists.whitelist = lists.whitelist.filter(s => s !== site);
      }

      // Update lists in background
      await updateSiteLists(lists.blacklist, lists.whitelist);

      // Refresh the UI lists
      populateSiteLists(lists.blacklist, lists.whitelist);
    }

    /**
     * Update site lists in background
     */
    async function updateSiteLists(blacklist, whitelist) {
      return new Promise((resolve) => {
        chrome.runtime.sendMessage({
          type: 'FOCUS_UPDATE_SITES',
          blacklist,
          whitelist
        }, (response) => {
          resolve(response && response.success);
        });
      });
    }

    /**
     * Add a new site to the blacklist or whitelist
     */
    async function addSite(input, listType) {
      const site = input.value.trim().toLowerCase();

      // Validate input - simple domain format validation
      if (!site || !isValidDomain(site)) {
        alert('Please enter a valid domain (e.g., facebook.com, twitter.com)');
        return;
      }

      // Get current lists
      const lists = await getSiteLists();

      // Check if site already exists
      if ((listType === 'blacklist' && lists.blacklist.includes(site)) ||
          (listType === 'whitelist' && lists.whitelist.includes(site))) {
        alert(`${site} is already in the ${listType === 'blacklist' ? 'blocked' : 'allowed'} sites list.`);
        return;
      }

      // Add site to appropriate list
      if (listType === 'blacklist') {
        lists.blacklist.push(site);
      } else {
        lists.whitelist.push(site);
      }

      // Update lists in background
      await updateSiteLists(lists.blacklist, lists.whitelist);

      // Clear input
      input.value = '';

      // Refresh the UI lists
      populateSiteLists(lists.blacklist, lists.whitelist);
    }

    /**
     * Validate domain format
     * Simple validation to ensure it looks like a domain
     */
    function isValidDomain(domain) {
      // Simple regex for basic domain validation
      const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$/;
      return domainRegex.test(domain);
    }

    /**
     * Set default values for time inputs
     */
    function setDefaultTimes() {
      // Default end time: 1 hour from now
      const oneHourLater = new Date();
      oneHourLater.setHours(oneHourLater.getHours() + 1);
      const endTimeString = oneHourLater.toTimeString().slice(0, 5); // Format: HH:MM
      elements.endTime.value = endTimeString;

      // Default start time: now
      const now = new Date();
      const startTimeString = now.toTimeString().slice(0, 5); // Format: HH:MM
      elements.startTime.value = startTimeString;
    }

    /**
     * Handle changes to block type select
     */
    function handleBlockTypeChange() {
      const blockType = elements.blockType.value;

      // Hide all options first
      elements.fixedTimeOptions.classList.remove('active');
      elements.untilTimeOptions.classList.remove('active');

      // Show relevant options based on selection
      if (blockType === 'timed') {
        elements.fixedTimeOptions.classList.add('active');
      } else if (blockType === 'untilTime') {
        elements.untilTimeOptions.classList.add('active');
      }
      // No options needed for indefinite
    }

    /**
     * Handle start now checkbox toggle
     */
    function handleStartNowToggle() {
      if (elements.startNow.checked) {
        elements.delayedStartOptions.classList.remove('active');
      } else {
        elements.delayedStartOptions.classList.add('active');
      }
    }

    /**
     * Start focus mode
     */
    async function startFocusMode() {
      const blockMode = elements.blockType.value;
      const startNow = elements.startNow.checked;

      let startTime, endTime;
      const now = new Date();

      // Set start time
      if (startNow) {
        startTime = now;
      } else {
        // Parse start time
        const [hours, minutes] = elements.startTime.value.split(':').map(Number);
        startTime = new Date(now);
        startTime.setHours(hours, minutes, 0);

        // If start time is in the past, set it to tomorrow
        if (startTime < now) {
          startTime.setDate(startTime.getDate() + 1);
        }
      }

      // Calculate end time based on block mode
      if (blockMode === 'timed') {
        // Get hours and minutes
        const hours = parseInt(elements.durationHours.value) || 0;
        const minutes = parseInt(elements.durationMinutes.value) || 0;

        // Ensure at least 1 minute
        if (hours === 0 && minutes === 0) {
          alert('Please set a duration of at least 1 minute.');
          return;
        }

        // Calculate end time
        endTime = new Date(startTime);
        endTime.setHours(endTime.getHours() + hours);
        endTime.setMinutes(endTime.getMinutes() + minutes);

      } else if (blockMode === 'untilTime') {
        // Parse end time
        const [hours, minutes] = elements.endTime.value.split(':').map(Number);
        endTime = new Date(now);
        endTime.setHours(hours, minutes, 0);

        // If end time is before start time, set it to tomorrow
        if (endTime < startTime) {
          endTime.setDate(endTime.getDate() + 1);
        }

      } else if (blockMode === 'indefinite') {
        // No end time for indefinite blocking
        endTime = null;
      }

      // Get site lists to make sure we have something to block
      const lists = await getSiteLists();

      if (!lists.blacklist || lists.blacklist.length === 0) {
        alert('Please add at least one site to block before starting focus mode.');
        return;
      }

      // Start focus mode in background
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({
          type: 'FOCUS_START',
          options: {
            blockMode,
            startNow,
            startTime: startTime.toISOString(),
            endTime: endTime ? endTime.toISOString() : null
          }
        }, (response) => {
          resolve(response);
        });
      });

      if (response && response.success) {
        // Update UI
        updateFocusStatus(true, endTime ? endTime.toISOString() : null);
      } else {
        alert('Failed to start focus mode. Please try again.');
      }
    }

    /**
     * Stop focus mode
     */
    async function stopFocusMode() {
      // Stop focus mode in background
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'FOCUS_STOP' }, (response) => {
          resolve(response);
        });
      });

      if (response && response.success) {
        // Update UI
        updateFocusStatus(false);
      } else {
        alert('Failed to stop focus mode. Please try again.');
      }
    }

    /**
     * Set up event listeners
     */
    function setupEventListeners() {
      // Focus mode controls
      elements.blockType.addEventListener('change', handleBlockTypeChange);
      elements.startNow.addEventListener('change', handleStartNowToggle);
      elements.startFocusBtn.addEventListener('click', startFocusMode);
      elements.stopFocusBtn.addEventListener('click', stopFocusMode);

      // Site list controls
      elements.addBlockedSiteBtn.addEventListener('click', () => {
        addSite(elements.blockedSiteInput, 'blacklist');
      });
      elements.addAllowedSiteBtn.addEventListener('click', () => {
        addSite(elements.allowedSiteInput, 'whitelist');
      });

      // Allow Enter key to add sites
      elements.blockedSiteInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          addSite(elements.blockedSiteInput, 'blacklist');
        }
      });
      elements.allowedSiteInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          addSite(elements.allowedSiteInput, 'whitelist');
        }
      });

      // Close button
      elements.closePageBtn.addEventListener('click', () => {
        window.close();
      });
    }

    // Initialize the page when DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializePage);
  </script>
</body>
</html>
